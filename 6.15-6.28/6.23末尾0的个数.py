import traceback
# 末尾为0 则 去掉
# 保留数的最后三位，保证1000以内的数相乘得到0的只可能是最后三位
try:
    n = int(input())
    res = 1
    totoalNum = 0
    for i in range(1, n + 1):
        res = res * i
        while (res % 10 == 0):
            res = res / 10
            totoalNum += 1
        res = res % 1000
    print(totoalNum)
except:
    traceback.print_exc()
    pass


# 另一种思路
# 最简单的思路就是把所有的数字进行分解质因数，例如：
# 6 = 2*3
# 15 = 3*5
# 64 = 2*2*2*2*2*2 = 2^6
# 100 = 2^2 * 5^2
# 576 = 2^6 * 3^2
# 那么我们在计算n的阶乘时，实际上就是把所有小于等于n的正整数分解成质因数，然后再将其乘到一起，那么末尾0的个数实际上就是2*5的个数，而2的个数明显是很多很多的，所以问题就转化成了5的个数。
# 而只有5的倍数才有5这个因数，所以，问题就进一步简化为小于等于n的数中有多少个数是5的倍数
# 比如100/5=20，即有20个数包含因数5：5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100。这20个数中又有20/5=4个包含因数5:25,50,75,100（可以把前面的20个数看成5*1，5*2，5*3，5*4，5*5，5*6，5*7，5*8，5*9，5*10,，5*11，5,12，5*13，5*14，5*15，5*16，5*17，5*18，5*19，5*20），然后这4个数中的因数5又被计算过了，即可。